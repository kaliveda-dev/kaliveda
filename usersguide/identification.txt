% KaliVeda User's Guide

# Particle identification #

Particle identification in KaliVeda is handled by the [KVIDTelescope] class family.
A basic [KVIDTelescope] associates 2 successive detectors on any of the particle trajectories through
the array which in principle can provide $\Delta E$-$E$ identification.
Specialised classes are available to handle single-detector identification methods as required (such as PSA
in silicon detectors [KVFAZIAIDSiPSA], or fast-slow identification in CsI(Tl) crystals [KVIDINDRACsI]).

The actual identification procedure can be handled in different ways, but the method which
attempts to identify whatever passed through the detector(s) is

~~~~~~~~~{.cpp}
KVIDTelescope::Identify(KVIdentificationResult*, Double_t x=-1, Double_t y=-1)
~~~~~~~~~

`x` and `y` here refer to coordinates in a 2-D identification map (for $\Delta E$-$E$ identification
we would have `x`=$E$ and `y`=$\Delta E$). The results of the identification attempt are returned
in the [KVIdentificationResult] object passed as first argument. This is a very detailed report on
how well (or not) the identification went (see class reference page [KVIdentificationResult] for details).

As the `x` and `y` arguments have default values, this method can be called without providing their
values, and indeed this is how it is used most of the time. In this case the methods

~~~~~~~~~{.cpp}
KVIDTelescope::GetIDMapX(Option_t* = "")
KVIDTelescope::GetIDMapY(Option_t* = "")
~~~~~~~~~

are used to provide the coordinates in the identification map. As will be seen below, the values to
be used for the coordinates can be automatically deduced if a single identification grid is used.

## Identification grids ##

The most common way of implementing the identification of particles is by defining identification grids,
which are a collection of lines and contours in a 2-D map which can be used to reject or accept particles,
assign them a value of $Z$ and/or $A$, depending on where they fall in the map, and this in turn depends
on how we assign $(x,y)$ coordinates to each particle. 

### X- and Y-coordinates (`VARX`,`VARY`) ###

This decision is made when histograms are prepared
from data in order to draw the identification grid. Naively, for a simple $\Delta E$-$E$ telescope,
one would think to fill this histogram as follows:

~~~~~~~~~{.cpp}
// supposing TH2F* myhisto (pointer to predefined 2-D histogram)
// and KVIDTelescope* idt (pointer to current DE-E identification telescope)
myhisto->Fill(idt->GetDetector(2)->GetDetectorSignalValue("Energy"),
   idt->GetDetector(1)->GetDetectorSignalValue("Energy"));
~~~~~~~~~

using the calibrated energy of each of the two detectors (see [Detector signals and calibrations]).
However this is unlikely and discouraged for two reasons:

  * we don't want to wait for detector calibration before implementing the identifications
  * if we use a calibration to set up identification maps, what happens if the calibrations are later changed? Redo the identification!
  
One is therefore more likely to use some 'raw' data signal for each detector, or a combination of them (the following
example is just to illustrate the possibilities, not a serious suggestion):

~~~~~~~~~{.cpp}
double X = idt->GetDetector(2)->GetDetectorSignalValue("Q3Amplitude")
              /idt->GetDetector(2)->GetDetectorSignalValue("Q3RiseTime");
double Y = idt->GetDetector(1)->GetDetectorSignalValue("Q2FPGAEnergy")
              +idt->GetDetector(1)->GetDetectorSignalValue("I2Amplitude");
myhisto->Fill(X,Y);
~~~~~~~~~

assuming of course that all of the above signals exist for each of the two detectors (see [Detector signals and calibrations]).

Next you draw your grid(s), and as long as you define the `VARX`, `VARY` parameters (using the graphical interface,
[KVIDGridEditor]) to be

~~~~~~~~~~
VARX : Q3Amplitude/Q3RiseTime
VARY : Q2FPGAEnergy+I2Amplitude
~~~~~~~~~~

then when the grid will be loaded by the identification telescope using

~~~~~~~~~~{.cpp}
// assuming KVIDGraph* mygrid is a pointer to your grid
idt->SetGrid(mygrid);
~~~~~~~~~~

the default `GetIDMapX/Y` methods of [KVIDTelescope] will automatically return the
correct values for your grid, according to the expressions in `VARX` and `VARY`.


[KVIDTelescope]: http://indra.in2p3.fr/kaliveda/doc/master/classKVIDTelescope.html
[KVGeoDNTrajectory]: http://indra.in2p3.fr/kaliveda/doc/master/classKVGeoDNTrajectory.html
[KVFAZIAIDSiPSA]: http://indra.in2p3.fr/kaliveda/doc/master/classKVFAZIAIDSiPSA.html
[KVIDINDRACsI]: http://indra.in2p3.fr/kaliveda/doc/master/classKVIDINDRACsI.html
[KVIdentificationResult]: http://indra.in2p3.fr/kaliveda/doc/master/classKVIdentificationResult.html
[Detector signals and calibrations]: calibrations.html
[KVIDGridEditor]: http://indra.in2p3.fr/kaliveda/doc/master/classKVIDGridEditor.html
